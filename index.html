<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Dome.js</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/dat.gui.min.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">
			varying vec3 vColor;
			void main() {
				vColor = color;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = 0.05 * ( 300.0 / -mvPosition.z );
				gl_Position = projectionMatrix * mvPosition;
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform sampler2D texture;
			varying vec3 vColor;
			void main() {
				gl_FragColor = vec4( vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
			}
		</script>

		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			var controls = new THREE.OrbitControls(camera);
			var gui = new dat.GUI();
			gui.add(controls, 'autoRotate');

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			const ledcount = 10520;

			// Prepare the dome shader
			var uniforms = {
				texture:   { value: new THREE.TextureLoader().load( "spark1.png" ) }
			};

			var colours = [];

			for (var i = 0; i < ledcount; i++) {
				colours.push(1.0, 1.0, 1.0)
			}

			var ledsmaterial = new THREE.ShaderMaterial( {
				uniforms:       uniforms,
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true,
				vertexColors:   true
			});

			var led_particle_geo = new THREE.BufferGeometry();
			led_particle_geo.addAttribute('color', new THREE.Float32BufferAttribute(colours, 3).setDynamic(true));

			// Load the LED geometry
			var loader = new THREE.FileLoader();
			loader.load(
				'ledlist.json',

				// onLoad callback
				function ( data ) {
					var leds = JSON.parse(data);

					var leds_destructured = leds.reduce((wip, led) => wip.concat(led));

					led_particle_geo.addAttribute('position', new THREE.Float32BufferAttribute(leds_destructured, 3));

					var ledparticles = new THREE.Points(led_particle_geo, ledsmaterial);

					ledparticles.rotation.x = -1 * Math.PI / 2;

					scene.add(ledparticles);
				},
			);

			var axesHelper = new THREE.AxesHelper( 5 );
			scene.add( axesHelper );

			gui.add(axesHelper, 'visible').name('Show Axes');

			camera.position.x = 5;
			// camera.position.y = 3;

			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			}

			animate();

		function animate() {
			requestAnimationFrame( animate );
			render();
		}

		function updateColours() {
			// Construct a sort-of sinusoidal wave pattern
			var colours = led_particle_geo.attributes.color.array;

			var wave_hz = 1;
			var r_offset = 0;
			var g_offset = 2 * Math.PI / 3;
			var b_offset = 4 * Math.PI / 3;

			for ( var i = 0; i < ledcount; i++ ) {
				relativeTime = (Date.now() / 1000) * (2 * Math.PI * wave_hz) + (2 * Math.PI * i / ledcount);

				var randVal = Math.random();
				colours[3 * i] = Math.sin(relativeTime + r_offset) / 2 + 1;
				colours[3 * i + 1] = Math.sin(relativeTime + g_offset) / 2 + 1;
				colours[3 * i + 2] = Math.sin(relativeTime + b_offset) / 2 + 1;
			}
			led_particle_geo.attributes.color.needsUpdate = true;
		}

		function render() {
			updateColours();
			renderer.render( scene, camera );
		}
		</script>
	</body>
</html>